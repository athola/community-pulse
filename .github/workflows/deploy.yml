name: Deploy to Supabase

on:
  push:
    branches: [master]

env:
  SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
  SUPABASE_PROJECT_REF: ${{ secrets.SUPABASE_PROJECT_REF }}
  SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}

jobs:
  deploy-backend:
    name: Deploy Backend (Migrations + Edge Functions)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check Supabase configuration
        id: check-config
        run: |
          if [ -z "$SUPABASE_ACCESS_TOKEN" ] || [ -z "$SUPABASE_PROJECT_REF" ]; then
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "::warning::Supabase secrets not configured. Skipping deployment."
          else
            echo "configured=true" >> $GITHUB_OUTPUT
          fi

      - name: Set up Supabase CLI
        if: steps.check-config.outputs.configured == 'true'
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Link Supabase project
        if: steps.check-config.outputs.configured == 'true'
        run: |
          set -e
          echo "Linking to project: $SUPABASE_PROJECT_REF"
          if ! output=$(supabase link --project-ref "$SUPABASE_PROJECT_REF" 2>&1); then
            echo "$output"
            echo "::error::Failed to link Supabase project"
            echo "::notice::Common causes:"
            echo "  - SUPABASE_ACCESS_TOKEN expired (regenerate at supabase.com/dashboard/account/tokens)"
            echo "  - SUPABASE_PROJECT_REF incorrect (check Settings > General in Supabase dashboard)"
            echo "  - Network connectivity issues"
            exit 1
          fi

      - name: Check for migrations
        if: steps.check-config.outputs.configured == 'true'
        id: check-migrations
        run: |
          if [ ! -d "supabase/migrations" ]; then
            echo "has_migrations=false" >> $GITHUB_OUTPUT
            echo "::notice::supabase/migrations directory does not exist, skipping migrations"
          elif ls supabase/migrations/*.sql 1>/dev/null 2>&1; then
            echo "has_migrations=true" >> $GITHUB_OUTPUT
          else
            echo "has_migrations=false" >> $GITHUB_OUTPUT
            echo "::notice::No .sql files in supabase/migrations/, skipping migrations"
          fi

      - name: Deploy database migrations
        if: steps.check-config.outputs.configured == 'true' && steps.check-migrations.outputs.has_migrations == 'true'
        run: |
          echo "Pushing database migrations..."
          if ! output=$(supabase db push 2>&1); then
            echo "$output"
            echo "::error::Database migration failed"
            echo "::notice::Common causes:"
            echo "  - SQL syntax error in migration file"
            echo "  - Constraint violation (foreign key, unique)"
            echo "  - Migration already applied with different content"
            echo "  - Network connectivity issues with Supabase"
            exit 1
          fi
          echo "$output"
          echo "✓ Database migrations applied successfully"

      - name: Check for Edge Functions
        if: steps.check-config.outputs.configured == 'true'
        id: check-functions
        run: |
          if find supabase/functions -mindepth 1 -maxdepth 1 -type d 2>/dev/null | grep -q .; then
            echo "has_functions=true" >> $GITHUB_OUTPUT
          else
            echo "has_functions=false" >> $GITHUB_OUTPUT
            echo "No Edge Functions found in supabase/functions/"
          fi

      - name: Deploy Edge Functions
        if: steps.check-config.outputs.configured == 'true' && steps.check-functions.outputs.has_functions == 'true'
        run: |
          echo "Deploying Edge Functions..."
          shopt -s nullglob
          for func_dir in supabase/functions/*/; do
            func_name=$(basename "$func_dir")
            # Skip _shared directory - contains shared code imported by functions, not a deployable function itself
            if [ "$func_name" = "_shared" ]; then
              continue
            fi
            echo "::group::Deploying $func_name"
            if supabase functions deploy "$func_name" 2>&1; then
              echo "✓ $func_name deployed successfully"
            else
              echo "::error::Failed to deploy function: $func_name"
              echo "::notice::Common causes:"
              echo "  - TypeScript compilation errors in supabase/functions/$func_name/"
              echo "  - Invalid imports (check Deno compatibility)"
              echo "  - Function exceeds size limit"
              echo "::endgroup::"
              exit 1
            fi
            echo "::endgroup::"
          done

  deploy-frontend:
    name: Deploy Frontend (Static Hosting)
    runs-on: ubuntu-latest
    needs: deploy-backend
    # Always run after backend (even if skipped), but deployment steps are conditional
    if: always()
    defaults:
      run:
        working-directory: frontend
    env:
      EXPO_PUBLIC_API_URL: ${{ secrets.SUPABASE_API_URL }}
    steps:
      - uses: actions/checkout@v4

      - name: Check Supabase configuration
        id: check-config
        working-directory: .
        run: |
          if [ -z "$SUPABASE_ACCESS_TOKEN" ] || [ -z "$SUPABASE_PROJECT_REF" ]; then
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "::warning::Supabase secrets not configured. Skipping frontend deployment to Supabase Storage."
          elif [ -z "$SUPABASE_SERVICE_ROLE_KEY" ]; then
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "::error::SUPABASE_SERVICE_ROLE_KEY secret is required for Storage operations."
            echo "::notice::Add the service_role key from your Supabase project settings (Settings > API > service_role key)"
          else
            echo "configured=true" >> $GITHUB_OUTPUT
          fi

      - name: Set up Node.js
        if: steps.check-config.outputs.configured == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        if: steps.check-config.outputs.configured == 'true'
        run: npm ci

      - name: Build static web app
        if: steps.check-config.outputs.configured == 'true'
        run: npx expo export --platform web

      - name: Set up Supabase CLI
        if: steps.check-config.outputs.configured == 'true'
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Deploy to Supabase Storage
        if: steps.check-config.outputs.configured == 'true'
        working-directory: .
        run: |
          set -e
          echo "Linking to project: $SUPABASE_PROJECT_REF"
          if ! supabase link --project-ref "$SUPABASE_PROJECT_REF" 2>&1; then
            echo "::error::Failed to link Supabase project"
            echo "::notice::Common causes:"
            echo "  - SUPABASE_ACCESS_TOKEN expired (regenerate at supabase.com/dashboard/account/tokens)"
            echo "  - SUPABASE_PROJECT_REF incorrect (check Settings > General in Supabase dashboard)"
            echo "  - Network connectivity issues"
            exit 1
          fi

          # Create or verify bucket using Storage REST API
          # This is the correct way to create buckets - SQL inserts don't register with the Storage service
          STORAGE_API_URL="https://${SUPABASE_PROJECT_REF}.supabase.co/storage/v1"

          echo "Checking if bucket 'website' exists via REST API..."
          set +e
          bucket_response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
            -H "apikey: $SUPABASE_SERVICE_ROLE_KEY" \
            "${STORAGE_API_URL}/bucket/website")
          bucket_status=$(echo "$bucket_response" | tail -n1)
          bucket_body=$(echo "$bucket_response" | sed '$d')
          set -e

          echo "Bucket check status: $bucket_status"

          if [ "$bucket_status" = "200" ]; then
            echo "Bucket 'website' already exists"
          elif [ "$bucket_status" = "404" ] || [ "$bucket_status" = "400" ]; then
            echo "Creating bucket 'website' via Storage REST API..."
            set +e
            create_response=$(curl -s -w "\n%{http_code}" \
              -X POST \
              -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
              -H "apikey: $SUPABASE_SERVICE_ROLE_KEY" \
              -H "Content-Type: application/json" \
              -d '{
                "id": "website",
                "name": "website",
                "public": true,
                "file_size_limit": 52428800,
                "allowed_mime_types": ["text/html", "text/css", "application/javascript", "application/json", "image/png", "image/jpeg", "image/gif", "image/svg+xml", "image/webp", "image/x-icon", "font/woff", "font/woff2", "application/font-woff", "application/font-woff2"]
              }' \
              "${STORAGE_API_URL}/bucket")
            create_status=$(echo "$create_response" | tail -n1)
            create_body=$(echo "$create_response" | sed '$d')
            set -e

            echo "Create bucket response: $create_status"
            echo "Response body: $create_body"

            if [ "$create_status" = "200" ] || [ "$create_status" = "201" ]; then
              echo "Bucket 'website' created successfully"
            elif echo "$create_body" | grep -qi "already exists"; then
              echo "Bucket 'website' already exists (race condition handled)"
            else
              echo "::error::Failed to create storage bucket 'website' (HTTP $create_status)"
              echo "::notice::Response: $create_body"
              echo "::notice::Common causes:"
              echo "  - SUPABASE_SERVICE_ROLE_KEY not configured or invalid"
              echo "  - Storage service unavailable"
              echo "  - Project paused"
              exit 1
            fi

            # Wait a moment for bucket to be fully available
            echo "Waiting for bucket to be available..."
            sleep 3
          else
            echo "::error::Unexpected response checking bucket (HTTP $bucket_status)"
            echo "::notice::Response: $bucket_body"
            echo "::notice::Verify SUPABASE_SERVICE_ROLE_KEY is correctly configured"
            exit 1
          fi

          # Verify bucket is accessible before uploading
          echo "Verifying bucket is accessible..."
          set +e
          verify_response=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
            -H "apikey: $SUPABASE_SERVICE_ROLE_KEY" \
            "${STORAGE_API_URL}/bucket/website")
          verify_status=$(echo "$verify_response" | tail -n1)
          set -e

          if [ "$verify_status" != "200" ]; then
            echo "::error::Bucket verification failed (HTTP $verify_status)"
            echo "::notice::The bucket may not be ready. Try re-running the workflow."
            exit 1
          fi
          echo "Bucket 'website' verified and ready for uploads"

          # Get MIME type without charset suffix (Supabase Storage rejects charset)
          get_mime_type() {
            local file="$1"
            local ext="${file##*.}"
            case "$ext" in
              html) echo "text/html" ;;
              css) echo "text/css" ;;
              js) echo "application/javascript" ;;
              json) echo "application/json" ;;
              png) echo "image/png" ;;
              jpg|jpeg) echo "image/jpeg" ;;
              gif) echo "image/gif" ;;
              svg) echo "image/svg+xml" ;;
              webp) echo "image/webp" ;;
              ico) echo "image/x-icon" ;;
              woff) echo "font/woff" ;;
              woff2) echo "font/woff2" ;;
              map) echo "application/json" ;;
              *) echo "application/octet-stream" ;;
            esac
          }

          # Upload function using REST API with retry logic
          # Uses REST API directly to control Content-Type header (CLI adds charset which is rejected)
          upload_file() {
            local file="$1"
            local rel_path="$2"
            local mime_type=$(get_mime_type "$file")
            local max_attempts=3

            for attempt in $(seq 1 $max_attempts); do
              set +e
              response=$(curl -s -w "\n%{http_code}" \
                -X POST \
                -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
                -H "apikey: $SUPABASE_SERVICE_ROLE_KEY" \
                -H "Content-Type: $mime_type" \
                -H "x-upsert: true" \
                --data-binary @"$file" \
                "${STORAGE_API_URL}/object/website/$rel_path")
              status=$(echo "$response" | tail -n1)
              set -e

              if [ "$status" = "200" ] || [ "$status" = "201" ]; then
                return 0
              fi

              if [ "$attempt" -lt "$max_attempts" ]; then
                echo "Retry $attempt/$max_attempts for $rel_path (HTTP $status)..."
                sleep $((attempt * 2))
              fi
            done
            echo "Failed: $rel_path (HTTP $status)"
            return 1
          }

          # Upload all static files recursively with error checking
          upload_count=0
          fail_count=0
          while IFS= read -r file; do
            rel_path="${file#frontend/dist/}"
            if upload_file "$file" "$rel_path"; then
              upload_count=$((upload_count + 1))
            else
              echo "::error::Failed to upload after retries: $rel_path"
              fail_count=$((fail_count + 1))
            fi
          done < <(find frontend/dist -type f)
          echo "Uploaded $upload_count files"
          if [ "$fail_count" -gt 0 ]; then
            echo "::error::$fail_count files failed to upload"
            exit 1
          fi
