name: Deploy to Supabase

on:
  push:
    branches: [master]

env:
  SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
  SUPABASE_PROJECT_REF: ${{ secrets.SUPABASE_PROJECT_REF }}

jobs:
  deploy-backend:
    name: Deploy Backend (Migrations + Edge Functions)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check Supabase configuration
        id: check-config
        run: |
          if [ -z "$SUPABASE_ACCESS_TOKEN" ] || [ -z "$SUPABASE_PROJECT_REF" ]; then
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "::warning::Supabase secrets not configured. Skipping deployment."
          else
            echo "configured=true" >> $GITHUB_OUTPUT
          fi

      - name: Set up Supabase CLI
        if: steps.check-config.outputs.configured == 'true'
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Link Supabase project
        if: steps.check-config.outputs.configured == 'true'
        run: |
          set -e
          echo "Linking to project: $SUPABASE_PROJECT_REF"
          if ! output=$(supabase link --project-ref "$SUPABASE_PROJECT_REF" 2>&1); then
            echo "$output"
            echo "::error::Failed to link Supabase project"
            echo "::notice::Common causes:"
            echo "  - SUPABASE_ACCESS_TOKEN expired (regenerate at supabase.com/dashboard/account/tokens)"
            echo "  - SUPABASE_PROJECT_REF incorrect (check Settings > General in Supabase dashboard)"
            echo "  - Network connectivity issues"
            exit 1
          fi

      - name: Check for migrations
        if: steps.check-config.outputs.configured == 'true'
        id: check-migrations
        run: |
          if [ ! -d "supabase/migrations" ]; then
            echo "has_migrations=false" >> $GITHUB_OUTPUT
            echo "::notice::supabase/migrations directory does not exist, skipping migrations"
          elif ls supabase/migrations/*.sql 1>/dev/null 2>&1; then
            echo "has_migrations=true" >> $GITHUB_OUTPUT
          else
            echo "has_migrations=false" >> $GITHUB_OUTPUT
            echo "::notice::No .sql files in supabase/migrations/, skipping migrations"
          fi

      - name: Deploy database migrations
        if: steps.check-config.outputs.configured == 'true' && steps.check-migrations.outputs.has_migrations == 'true'
        run: |
          echo "Pushing database migrations..."
          if ! output=$(supabase db push 2>&1); then
            echo "$output"
            echo "::error::Database migration failed"
            echo "::notice::Common causes:"
            echo "  - SQL syntax error in migration file"
            echo "  - Constraint violation (foreign key, unique)"
            echo "  - Migration already applied with different content"
            echo "  - Network connectivity issues with Supabase"
            exit 1
          fi
          echo "$output"
          echo "✓ Database migrations applied successfully"

      - name: Check for Edge Functions
        if: steps.check-config.outputs.configured == 'true'
        id: check-functions
        run: |
          if find supabase/functions -mindepth 1 -maxdepth 1 -type d 2>/dev/null | grep -q .; then
            echo "has_functions=true" >> $GITHUB_OUTPUT
          else
            echo "has_functions=false" >> $GITHUB_OUTPUT
            echo "No Edge Functions found in supabase/functions/"
          fi

      - name: Deploy Edge Functions
        if: steps.check-config.outputs.configured == 'true' && steps.check-functions.outputs.has_functions == 'true'
        run: |
          echo "Deploying Edge Functions..."
          shopt -s nullglob
          for func_dir in supabase/functions/*/; do
            func_name=$(basename "$func_dir")
            # Skip _shared directory - contains shared code imported by functions, not a deployable function itself
            if [ "$func_name" = "_shared" ]; then
              continue
            fi
            echo "::group::Deploying $func_name"
            if supabase functions deploy "$func_name" 2>&1; then
              echo "✓ $func_name deployed successfully"
            else
              echo "::error::Failed to deploy function: $func_name"
              echo "::notice::Common causes:"
              echo "  - TypeScript compilation errors in supabase/functions/$func_name/"
              echo "  - Invalid imports (check Deno compatibility)"
              echo "  - Function exceeds size limit"
              echo "::endgroup::"
              exit 1
            fi
            echo "::endgroup::"
          done

  deploy-frontend:
    name: Deploy Frontend (Static Hosting)
    runs-on: ubuntu-latest
    needs: deploy-backend
    # Always run after backend (even if skipped), but deployment steps are conditional
    if: always()
    defaults:
      run:
        working-directory: frontend
    env:
      EXPO_PUBLIC_API_URL: ${{ secrets.SUPABASE_API_URL }}
    steps:
      - uses: actions/checkout@v4

      - name: Check Supabase configuration
        id: check-config
        working-directory: .
        run: |
          if [ -z "$SUPABASE_ACCESS_TOKEN" ] || [ -z "$SUPABASE_PROJECT_REF" ]; then
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "::warning::Supabase secrets not configured. Skipping frontend deployment to Supabase Storage."
          else
            echo "configured=true" >> $GITHUB_OUTPUT
          fi

      - name: Set up Node.js
        if: steps.check-config.outputs.configured == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        if: steps.check-config.outputs.configured == 'true'
        run: npm ci

      - name: Build static web app
        if: steps.check-config.outputs.configured == 'true'
        run: npx expo export --platform web

      - name: Set up Supabase CLI
        if: steps.check-config.outputs.configured == 'true'
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Deploy to Supabase Storage
        if: steps.check-config.outputs.configured == 'true'
        working-directory: .
        run: |
          set -e
          echo "Linking to project: $SUPABASE_PROJECT_REF"
          if ! supabase link --project-ref "$SUPABASE_PROJECT_REF" 2>&1; then
            echo "::error::Failed to link Supabase project"
            echo "::notice::Common causes:"
            echo "  - SUPABASE_ACCESS_TOKEN expired (regenerate at supabase.com/dashboard/account/tokens)"
            echo "  - SUPABASE_PROJECT_REF incorrect (check Settings > General in Supabase dashboard)"
            echo "  - Network connectivity issues"
            exit 1
          fi

          # Function to check if bucket exists (returns 0=exists, 1=not found, 2=error)
          bucket_exists() {
            local ls_output
            if ! ls_output=$(supabase storage ls 2>&1); then
              echo "::error::Failed to list storage buckets: $ls_output"
              return 2
            fi
            echo "$ls_output" | grep -q "^website$"
          }

          # Create bucket if it doesn't exist
          bucket_exists
          bucket_status=$?
          if [ "$bucket_status" -eq 2 ]; then
            echo "::notice::Common causes for storage list failure:"
            echo "  - SUPABASE_ACCESS_TOKEN expired or invalid"
            echo "  - Insufficient permissions on token"
            echo "  - Supabase service unavailable"
            exit 1
          elif [ "$bucket_status" -eq 0 ]; then
            echo "Bucket 'website' already exists"
          else
            echo "Creating bucket 'website'..."
            if ! supabase storage create website --public; then
              echo "::error::Failed to create storage bucket 'website'"
              echo "::notice::Common causes:"
              echo "  - Insufficient permissions on SUPABASE_ACCESS_TOKEN"
              echo "  - Storage quota exceeded"
              echo "  - Project paused or unavailable"
              exit 1
            fi
            echo "Bucket created, waiting for propagation..."
            # Wait for bucket to be available (max 30 seconds)
            for i in {1..6}; do
              sleep 5
              bucket_exists
              check_status=$?
              if [ "$check_status" -eq 0 ]; then
                echo "Bucket is now available"
                break
              elif [ "$check_status" -eq 2 ]; then
                echo "::error::Storage API error while waiting for bucket"
                exit 1
              fi
              if [ "$i" -eq 6 ]; then
                echo "::error::Bucket 'website' not available after 30 seconds"
                exit 1
              fi
              echo "Waiting for bucket... (attempt $i/6)"
            done
          fi

          # Upload function with retry logic
          upload_file() {
            local file="$1"
            local rel_path="$2"
            local max_attempts=3
            for attempt in $(seq 1 $max_attempts); do
              if supabase storage cp --experimental "$file" "ss:///website/$rel_path" 2>&1; then
                return 0
              fi
              if [ "$attempt" -lt "$max_attempts" ]; then
                echo "Retry $attempt/$max_attempts for $rel_path..."
                sleep $((attempt * 2))
              fi
            done
            return 1
          }

          # Upload all static files recursively with error checking
          upload_count=0
          fail_count=0
          while IFS= read -r file; do
            rel_path="${file#frontend/dist/}"
            if upload_file "$file" "$rel_path"; then
              upload_count=$((upload_count + 1))
            else
              echo "::error::Failed to upload after retries: $rel_path"
              fail_count=$((fail_count + 1))
            fi
          done < <(find frontend/dist -type f)
          echo "Uploaded $upload_count files"
          if [ "$fail_count" -gt 0 ]; then
            echo "::error::$fail_count files failed to upload"
            exit 1
          fi
